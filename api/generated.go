// Package api provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package api

// AccessTokenRequestFailedResponse defines model for AccessTokenRequestFailedResponse.
type AccessTokenRequestFailedResponse struct {
	Error string `json:"error"`

	// Human-readable ASCII text providing additional information, used to assist the client developer in understanding the error that occurred.
	ErrorDescription string `json:"error_description"`
}

// AccessTokenResponse defines model for AccessTokenResponse.
type AccessTokenResponse struct {

	// The access token issued by the authorization server.
	// Could be a signed JWT or a random number. It should not have a meaning to the client.
	AccessToken string `json:"access_token"`

	// The lifetime in seconds of the access token.
	ExpiresIn float32 `json:"expires_in"`

	// The type of the token issued
	TokenType string `json:"token_type"`
}

// Contract defines model for Contract.
type Contract struct {

	// Language of the contract in all caps
	Language           Language  `json:"language"`
	SignerAttributes   *[]string `json:"signer_attributes,omitempty"`
	Template           *string   `json:"template,omitempty"`
	TemplateAttributes *[]string `json:"template_attributes,omitempty"`

	// Type of which contract to sign
	Type Type `json:"type"`

	// Version of the contract
	Version Version `json:"version"`
}

// ContractLanguage defines model for ContractLanguage.
type ContractLanguage string

// ContractResponse defines model for ContractResponse.
type ContractResponse struct {

	// Language of the contract in all caps
	Language ContractLanguage `json:"language"`

	// The contract message
	Message string `json:"message"`

	// Type of which contract to sign
	Type ContractType `json:"type"`

	// Version of the contract
	Version ContractVersion `json:"version"`
}

// ContractSigningRequest defines model for ContractSigningRequest.
type ContractSigningRequest struct {

	// Language of the contract in all caps
	Language Language `json:"language"`

	// Identifier of the legalEntity as registered in the Nuts registry
	LegalEntity LegalEntity `json:"legalEntity"`

	// Type of which contract to sign
	Type Type `json:"type"`

	// ValidFrom describes the time from which this contract should be considered valid
	ValidFrom *string `json:"valid_from,omitempty"`

	// ValidTo describes the time until this contract should be considered valid
	ValidTo *string `json:"valid_to,omitempty"`

	// Version of the contract
	Version Version `json:"version"`
}

// ContractTemplateResponse defines model for ContractTemplateResponse.
type ContractTemplateResponse struct {

	// Language of the contract in all caps
	Language ContractLanguage `json:"language"`
	Template string           `json:"template"`

	// Type of which contract to sign
	Type ContractType `json:"type"`

	// Version of the contract
	Version ContractVersion `json:"version"`
}

// ContractType defines model for ContractType.
type ContractType string

// ContractVersion defines model for ContractVersion.
type ContractVersion string

// CreateAccessTokenRequest defines model for CreateAccessTokenRequest.
type CreateAccessTokenRequest struct {

	// Base64 encoded JWT following rfc7523 and the Nuts documentation
	Assertion string `json:"assertion"`

	// always must contain the value "urn:ietf:params:oauth:grant-type:jwt-bearer"
	GrantType string `json:"grant_type"`
}

// CreateJwtBearerTokenRequest defines model for CreateJwtBearerTokenRequest.
type CreateJwtBearerTokenRequest struct {
	Actor     string `json:"actor"`
	Custodian string `json:"custodian"`

	// Base64 encoded IRMA contract conaining the identity of the performer
	Identity string `json:"identity"`

	// Space-delimited list of strings. For what kind of operations can the access token be used? Scopes will be specified for each use-case
	Scope   string  `json:"scope"`
	Subject *string `json:"subject,omitempty"`
}

// CreateSessionResult defines model for CreateSessionResult.
type CreateSessionResult struct {

	// Qr contains the data of an IRMA session QR (as generated by irma_js), suitable for NewSession()
	QrCodeInfo IrmaQR `json:"qr_code_info"`

	// a session identifier
	SessionId string `json:"session_id"`
}

// CreateSignSessionRequest defines model for CreateSignSessionRequest.
type CreateSignSessionRequest struct {
	Means string `json:"means"`

	// Params are passed to the means. Should be documented in the means documentation.
	Params map[string]interface{} `json:"params"`

	// base64 encoded payload what needs to be signed
	Payload string `json:"payload"`
}

// CreateSignSessionResult defines model for CreateSignSessionResult.
type CreateSignSessionResult struct {

	// The means this session uses to sign.
	Means string `json:"means"`

	// A pointer to a signature session. This is an opaque value which only has meaning in the context of the signing means. Can be an URL, base64 encoded image of a QRCode etc.
	SessionPtr map[string]interface{} `json:"sessionPtr"`
}

// DisclosedAttribute defines model for DisclosedAttribute.
type DisclosedAttribute struct {
	Identifier string                 `json:"identifier"`
	Rawvalue   *string                `json:"rawvalue,omitempty"`
	Status     string                 `json:"status"`
	Value      map[string]interface{} `json:"value"`
}

// DisclosedAttributeIndex defines model for DisclosedAttributeIndex.
type DisclosedAttributeIndex struct {
	Attr *int `json:"attr,omitempty"`
	Cred *int `json:"cred,omitempty"`
}

// DrawUpContractRequest defines model for DrawUpContractRequest.
type DrawUpContractRequest struct {

	// Language of the contract in all caps
	Language ContractLanguage `json:"language"`

	// Identifier of the legalEntity as registered in the Nuts registry
	LegalEntity LegalEntity `json:"legalEntity"`

	// Type of which contract to sign
	Type ContractType `json:"type"`

	// The duration this contract is valid, starting from validFrom or current time if validFrom is omitted. Uses this node default when omitted. Valid time units are: 's', 'm', 'h'
	ValidDuration *string `json:"validDuration,omitempty"`

	// validFrom describes the time from which this contract should be considered valid. Current time is used when omitted.
	ValidFrom *string `json:"validFrom,omitempty"`

	// Version of the contract
	Version ContractVersion `json:"version"`
}

// ErrorString defines model for ErrorString.
type ErrorString string

// GetSignSessionStatusResult defines model for GetSignSessionStatusResult.
type GetSignSessionStatusResult struct {

	// Status indicates the status of the signing proces. Values depend on the implementation of the signing means.
	Status string `json:"status"`

	// If the signature session is completed, this property contains the signature embedded in an w3c verifiable presentation
	VerifiablePresentation *VerifiablePresentation `json:"verifiablePresentation,omitempty"`
}

// IrmaQR defines model for IrmaQR.
type IrmaQR struct {
	Irmaqr string `json:"irmaqr"`

	// Server with which to perform the session (URL)
	U string `json:"u"`
}

// JwtBearerTokenResponse defines model for JwtBearerTokenResponse.
type JwtBearerTokenResponse struct {
	BearerToken string `json:"bearer_token"`
}

// Language defines model for Language.
type Language string

// LegalEntity defines model for LegalEntity.
type LegalEntity string

// Proof defines model for Proof.
type Proof interface{}

// ProofD defines model for ProofD.
type ProofD struct {
	A          *float32                `json:"A,omitempty"`
	ADisclosed *map[string]interface{} `json:"a_disclosed,omitempty"`
	AResponses *map[string]interface{} `json:"a_responses,omitempty"`
	C          *float32                `json:"c,omitempty"`
	EResponse  *float32                `json:"e_response,omitempty"`
	VResponse  *float32                `json:"v_response,omitempty"`
}

// ProofP defines model for ProofP.
type ProofP struct {
	P         *float32 `json:"P,omitempty"`
	C         *float32 `json:"c,omitempty"`
	SResponse *float32 `json:"s_response,omitempty"`
}

// ProofS defines model for ProofS.
type ProofS struct {
	C         *float32 `json:"c,omitempty"`
	EResponse *float32 `json:"e_response,omitempty"`
}

// ProofU defines model for ProofU.
type ProofU struct {
	U              *float32 `json:"U,omitempty"`
	C              *float32 `json:"c,omitempty"`
	SResponse      *float32 `json:"s_response,omitempty"`
	VPrimeResponse *float32 `json:"v_prime_response,omitempty"`
}

// RemoteError defines model for RemoteError.
type RemoteError struct {
	Description *string `json:"description,omitempty"`
	Error       *string `json:"error,omitempty"`
	Message     *string `json:"message,omitempty"`
	Stacktrace  *string `json:"stacktrace,omitempty"`
	Status      *int    `json:"status,omitempty"`
}

// SessionResult defines model for SessionResult.
type SessionResult struct {
	Disclosed *[]DisclosedAttribute `json:"disclosed,omitempty"`
	Error     *RemoteError          `json:"error,omitempty"`

	// Base64 encoded JWT that can be used as Bearer Token
	NutsAuthToken *string        `json:"nuts_auth_token,omitempty"`
	ProofStatus   *string        `json:"proofStatus,omitempty"`
	Signature     *SignedMessage `json:"signature,omitempty"`
	Status        string         `json:"status"`

	// the token originally given in the request
	Token string `json:"token"`
	Type  string `json:"type"`
}

// SignatureVerificationRequest defines model for SignatureVerificationRequest.
type SignatureVerificationRequest struct {

	// If the signature session is completed, this property contains the signature embedded in an w3c verifiable presentation
	VerifiablePresentation VerifiablePresentation `json:"VerifiablePresentation"`
}

// SignatureVerificationResponse defines model for SignatureVerificationResponse.
type SignatureVerificationResponse bool

// SignedMessage defines model for SignedMessage.
type SignedMessage struct {
	Context   *float32                     `json:"context,omitempty"`
	Indices   *[][]DisclosedAttributeIndex `json:"indices,omitempty"`
	Message   *string                      `json:"message,omitempty"`
	Nonce     *float32                     `json:"nonce,omitempty"`
	Signature *[]Proof                     `json:"signature,omitempty"`
	Timestamp *Timestamp                   `json:"timestamp,omitempty"`
}

// Timestamp defines model for Timestamp.
type Timestamp struct {
	Time *int64 `json:"time,omitempty"`
}

// TokenIntrospectionRequest defines model for TokenIntrospectionRequest.
type TokenIntrospectionRequest struct {
	Token string `json:"token"`
}

// TokenIntrospectionResponse defines model for TokenIntrospectionResponse.
type TokenIntrospectionResponse struct {

	// True if the token is active, false if the token is expired, malformed etc.
	Active bool `json:"active"`

	// As per rfc7523 https://tools.ietf.org/html/rfc7523>, the aud must be the
	// token endpoint. This can be taken from the Nuts registry.
	Aud *string `json:"aud,omitempty"`

	// End-User's preferred e-mail address. Should be a personal email and can be used to uniquely identify a user. Just like the email used for an account.
	Email *string `json:"email,omitempty"`
	Exp   *int    `json:"exp,omitempty"`

	// Surname(s) or last name(s) of the End-User.
	FamilyName *string `json:"family_name,omitempty"`

	// Given name(s) or first name(s) of the End-User.
	GivenName *string `json:"given_name,omitempty"`
	Iat       *int    `json:"iat,omitempty"`

	// The subject (not a Nuts subject) contains the URN of the custodian.
	Iss *string `json:"iss,omitempty"`

	// End-User's full name in displayable form including all name parts, possibly including titles and suffixes, ordered according to the End-User's locale and preferences.
	Name *string `json:"name,omitempty"`

	// encoded ops signature. (TBD)
	Osi *string `json:"osi,omitempty"`

	// Surname prefix
	Prefix *string `json:"prefix,omitempty"`
	Scope  *string `json:"scope,omitempty"`

	// The Nuts subject id, patient identifier in the form of an oid encoded BSN.
	Sid *string `json:"sid,omitempty"`

	// The subject is always the acting party, thus the care organization requesting access to data.
	Sub *string `json:"sub,omitempty"`

	// Jwt encoded user identity.
	Usi *string `json:"usi,omitempty"`
}

// Type defines model for Type.
type Type string

// ValidationRequest defines model for ValidationRequest.
type ValidationRequest struct {

	// ActingPartyCN is the common name of the Acting party extracted from the client cert
	ActingPartyCn string `json:"acting_party_cn"`

	// ContractFormat specifies the type of format used for the contract
	ContractFormat string `json:"contract_format"`

	// Base64 encoded contracts, either Irma signature or a JWT
	ContractString string `json:"contract_string"`
}

// ValidationResult defines model for ValidationResult.
type ValidationResult struct {
	ContractFormat   string                 `json:"contract_format"`
	SignerAttributes map[string]interface{} `json:"signer_attributes"`
	ValidationResult string                 `json:"validation_result"`
}

// VerifiablePresentation defines model for VerifiablePresentation.
type VerifiablePresentation struct {
	Context []string               `json:"@context"`
	Proof   map[string]interface{} `json:"proof"`
	Type    []string               `json:"type"`
}

// Version defines model for Version.
type Version string

